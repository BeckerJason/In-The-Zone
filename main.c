#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in2,    LineM,          sensorLineFollower)
#pragma config(Sensor, in3,    LineL,          sensorLineFollower)
#pragma config(Sensor, in4,    pot,            sensorPotentiometer)
#pragma config(Sensor, in5,    LineR,          sensorLineFollower)
#pragma config(Sensor, in7,    gyro,           sensorGyro)
#pragma config(Sensor, in8,    Pexpander,      sensorAnalog)
#pragma config(Sensor, dgtl1,  enc,            sensorQuadEncoder)
#pragma config(Sensor, dgtl4,  limit,          sensorTouch)
#pragma config(Sensor, dgtl5,  Lsonar,         sensorSONAR_mm)
#pragma config(Sensor, dgtl7,  Rsonar,         sensorSONAR_mm)
#pragma config(Sensor, dgtl9,  Climit,         sensorTouch)
#pragma config(Sensor, dgtl10, IR,             sensorDigitalIn)
#pragma config(Sensor, dgtl12, Jumper,         sensorDigitalIn)
#pragma config(Sensor, I2C_1,  Renc,           sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  Lenc,           sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_3,  Larm,           sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_4,  Rarm,           sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_5,  FBencoder,      sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_6,  Rol,            sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           roller,        tmotorVex393_HBridge, openLoop, encoderPort, I2C_6)
#pragma config(Motor,  port2,           RM,            tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           R1,            tmotorVex393HighSpeed_MC29, openLoop, reversed, encoderPort, I2C_1)
#pragma config(Motor,  port4,           fb1,           tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_5)
#pragma config(Motor,  port5,           rightArm1,     tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_4)
#pragma config(Motor,  port6,           leftArm1,      tmotorVex393_MC29, openLoop, encoderPort, I2C_3)
#pragma config(Motor,  port7,           LM,            tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port8,           L1,            tmotorVex393HighSpeed_MC29, openLoop, encoderPort, I2C_2)
#pragma config(Motor,  port9,           fb2,           tmotorVex393_MC29, openLoop, encoderPort, I2C_5)
#pragma config(Motor,  port10,          MG,            tmotorVex393_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma DebuggerWindows("debugStream")
////    Jason Becker    ////
//// VCAT Robotics 2018 ////

#pragma platform(VEX2)

#pragma competitionControl(Competition)
#pragma autonomousDuration(45)
#pragma userControlDuration(75)

//~~~~~~~~ MAIN.C V2 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#define DEBUG 0
int alliance = 4;
int AllianceColor=1;
int autonomousN = 5;
int NearOrFar=0;
////////////// Voltage Check Function ////////////////
#include "CompensationCheck.c";
/////////////////////////////////////
/////////////////////// Mobile Gola Class
typedef struct
{
	int val;
	int stack;
}MOGO;
MOGO mobi;
//VVVVVVVVVVVVVVVVVVVVVV Voltage Check Class Structure VVVVVVVVVVVVVVVV
typedef struct
{
	float mult;
}TVoltage;
TVoltage pr;
TVoltage se;
//VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV
#include "Tasks.c"
//392 ticks for IME high-speed
#include "Functions.c"
#include "FullAuto.c"
#include "VexIncludes.c"

//****************** GLOBAL VARIABLES *****************
string in=in, out=out, hold=hold,nothing=nothing;
//*****************************************************
void pre_auton()
{		clearDebugStream();
	bStopTasksBetweenModes = true;
	mobi.val=0;
	mobi.stack=0;
	stopTask(autonomous);
	#include "PreAuto.c";
}

task autonomous()
{
//Roll(in);
//!!!!!!!!!! CHECK VOLTAGES !!!!!!!!!!!!!!!!!!!!!!!!!!!!!
pr.mult=PCheck(nImmediateBatteryLevel/1000.0);
se.mult=SCheck(SensorValue[Pexpander]/280.0);
//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//#include "MainAuto.c"
//FullAuto();
float VAr;
VAr=627.2;
setPIDforMotor(port1,true);
moveMotorTarget(port1,627.2 , 30);

// Wait for motor to move
motor[port1]=-10

}
task usercontrol()
{stopTask(autonomous);
//##########   RECORD  ####################################################
	int record;
	if (SensorValue[Jumper]==0)
	{record=1;}
	else{ record=0;}
//########################################################################
clearDebugStream();
#include "NorrinDriverControl.c";

}
